
# A. Make a triangle  by 庄云聪
 
## 题目大意:
  给你a,b,c三个整数（a,b,c均为1至100的整数），如果这三个数能构成三角形就输出0，否则可以对任意一条边n个1，输出至少加了多少次1就能构成三角形

## 题解
   判断能否构成后在不能的情况下用恰好构成的三角形短的两边之和的长度减去当前长度。

## 参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a,b,c,s;
    cin >> a >> b >> c;
    s=max(a,b);
    s=max(s,c);
    s=s-(a+b+c-s)+1;
    if(s<=0)
        s=0;
    cout << s << endl;
    return 0;}
```

# B. Equations of Mathematical Magic   By 周方全

## 题目大意
- 就是解一个方程：a−(a⊕x)−x=0
## 解题思路 
- a−(a⊕x)−x=0 <==> a−(a^x)−x=0  <==>  x^a = x-a
- 如果运算符  ‘^’与 ‘-’起到相同的效果的话就是一个解
- 分析四种比较;
- 1^1=0   1-1=0
- 1^0=1   1-0=1
- 0^0=0   0-0=0，
- 0^1=1   0-1=-1
- 当a的二进制表示，如果这个位是1，则x对应的二进制对应的位数是0或者1都行；如果这个位是0，则x对应的二进制对应的位数只能是0。
- 所以，a的二进制表示有几个1就有2的几次方的情况。

## AC代码
```cpp
- #include <iostream>
- #include <cstdio>
- #include <cmath>
- using namespace std;

- int T;
- int main(){
- 	int a;
- 	int b;
- 	cin>>T;
- 	while(T--){
- 		int ans=1;
- 		scanf("%d",&a);
- 		int di=0;
- 		while(a){
- 			if(a&1){
- 				a/=2;
- 				di++;
- 			}
- 			else {
- 				a/=2;
- 			}
- 		}
- 	    ans=pow(2,di);
- 		printf("%d\n",ans);
- 	}
- } 
```
# C  By 徐宗浩

题意是给出一个乱序的字符串，求它的一种排列，使得它的所有字串中是回文串的数量是最大的。字串的定义是，从该字符串前端、后端扔掉一些元素（可以不扔）。这样就意味着不能从中间去掉元素。

开始我的想法是，建立一个尽可能两边对称的字符串，找到这个长度的中点，从它开始一左一右地放元素，这样容易达到回文的效果。

这样的想法是一种直觉性的想法，看到样例以后我觉得不是这样的。

输出的样例是ololo和abccbaghghghgdfd，后者的gh反复出现，前者的ol反复出现。于是我直觉性地产生一种想法，会不会尽量让两个字母交替出现，能够更大地构造出回文串？于是我准备实现这个算法，让数量相近的两个字母交替出现，比如a和b是所有字母当中最多的，那就让a和b交替出现。

这时候我注意到了第二个例子中有abccba这一段，这是由三个字母构成的。那我前面的结论还适用吗？我把它换成ababcc，发现总数依然是一样的。于是我准备实现这个算法。

写着写着觉得有点复杂，突然想到，既然把三个字母变成两个字母交替可以等价，那把尽量让两个字母的交替出现变成尽量让一个字母重复出现呢？把这一段换成aabbcc，可以发现依然是等价的。

我看到题目中举出的aaa有6个回文子串，数量非常多。这是一种暗示吗。

于是我就把相同的字母放在一起输出。于是就过了。

对，我还是不知道为什么，但是就是这么一路瞎折腾过来过了。
 
